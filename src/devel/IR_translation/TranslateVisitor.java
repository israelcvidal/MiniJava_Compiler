package devel.IR_translation;import java.util.ArrayList;import java.util.LinkedList;import java.util.List;import core.abstract_syntax.syntaxtree.And;import core.abstract_syntax.syntaxtree.ArrayAssign;import core.abstract_syntax.syntaxtree.ArrayLength;import core.abstract_syntax.syntaxtree.ArrayLookup;import core.abstract_syntax.syntaxtree.Assign;import core.abstract_syntax.syntaxtree.Block;import core.abstract_syntax.syntaxtree.BooleanType;import core.abstract_syntax.syntaxtree.Call;import core.abstract_syntax.syntaxtree.ClassDeclExtends;import core.abstract_syntax.syntaxtree.ClassDeclSimple;import core.abstract_syntax.syntaxtree.False;import core.abstract_syntax.syntaxtree.Formal;import core.abstract_syntax.syntaxtree.Identifier;import core.abstract_syntax.syntaxtree.IdentifierExp;import core.abstract_syntax.syntaxtree.IdentifierType;import core.abstract_syntax.syntaxtree.If;import core.abstract_syntax.syntaxtree.IntArrayType;import core.abstract_syntax.syntaxtree.IntegerLiteral;import core.abstract_syntax.syntaxtree.IntegerType;import core.abstract_syntax.syntaxtree.LessThan;import core.abstract_syntax.syntaxtree.MainClass;import core.abstract_syntax.syntaxtree.MethodDecl;import core.abstract_syntax.syntaxtree.Minus;import core.abstract_syntax.syntaxtree.NewArray;import core.abstract_syntax.syntaxtree.NewObject;import core.abstract_syntax.syntaxtree.Not;import core.abstract_syntax.syntaxtree.Plus;import core.abstract_syntax.syntaxtree.Print;import core.abstract_syntax.syntaxtree.Program;import core.abstract_syntax.syntaxtree.Statement;import core.abstract_syntax.syntaxtree.This;import core.abstract_syntax.syntaxtree.Times;import core.abstract_syntax.syntaxtree.True;import core.abstract_syntax.syntaxtree.Type;import core.abstract_syntax.syntaxtree.VarDecl;import core.abstract_syntax.syntaxtree.While;import core.activation_records.frame.Frame;import core.activation_records.temp.Label;import core.activation_records.temp.Temp;import core.translation_to_IR.tree.AbstractExp;import core.translation_to_IR.tree.BINOP;import core.translation_to_IR.tree.CALL;import core.translation_to_IR.tree.CJUMP;import core.translation_to_IR.tree.CONST;import core.translation_to_IR.tree.ESEQ;import core.translation_to_IR.tree.EXP;import core.translation_to_IR.tree.ExpList;import core.translation_to_IR.tree.JUMP;import core.translation_to_IR.tree.LABEL;import core.translation_to_IR.tree.MEM;import core.translation_to_IR.tree.MOVE;import core.translation_to_IR.tree.NAME;import core.translation_to_IR.tree.SEQ;import core.translation_to_IR.tree.Stm;import core.translation_to_IR.tree.TEMP;import devel.semantic_analysis.ClassTable;import devel.semantic_analysis.MethodTable;import devel.semantic_analysis.ProgramTable;import devel.semantic_analysis.Symbol;/** * The class implements the translate to IR tree. * @author daniel * */public class TranslateVisitor implements IRVisitor {	private Frame currenFrame;	private ProgramTable programTable;	private String identifierClass = null;	private ClassTable currenClass = null;	private ClassTable instanceClass = null;	private MethodTable currenMethod = null;	private List<Frag> fragsResult = new LinkedList<Frag>();	public TranslateVisitor(Frame currenFrame, ProgramTable programTable) {		this.currenFrame = currenFrame;		this.programTable = programTable;	}		@Override	public List<Frag> visit(Program n) {		n.m.accept(this);				for (int i = 0; i < n.cl.size(); i++)			n.cl.elementAt(i).accept(this);       		fragsResult.add(new DataFrag(currenFrame.programTail()));       		return fragsResult;	}	@Override	public Stm visit(MainClass n) {    	currenClass = programTable.getClass(n.i1.s);            	List<Boolean> formals = new LinkedList<Boolean>();      	formals.add(false);      	Frame frame = currenFrame;    	currenFrame = frame.newFrame(Symbol.symbol("main"), formals);      	Stm stm = n.s.accept(this);      	List<Stm> body = new ArrayList<Stm>();    	body.add(stm);      	currenFrame.procEntryExit1(body);      	ProcFrag frag = new ProcFrag(currenFrame, stm);    	fragsResult.add(frag);      	currenFrame = frame;      	currenClass = null;      	return null;	}	@Override	public Stm visit(ClassDeclSimple n) {    	currenClass = programTable.getClass(n.i.s);    	for (int i = 0; i < n.ml.size(); i++)    		n.ml.elementAt(i).accept(this);           	currenClass = null;           	return null;	}	@Override	public Stm visit(ClassDeclExtends n) {    	currenClass = programTable.getClass(n.i.s);    	for (int i = 0; i < n.ml.size(); i++)    		n.ml.elementAt(i).accept(this);           	currenClass = null;           	return null;	}	@Override	public Stm visit(VarDecl n) {		return null;	}	@Override	public Stm visit(MethodDecl n) {    	currenMethod = currenClass.getMethod(n.i.s);            	List<Boolean> formals = new LinkedList<Boolean>();        	formals.add(false);    	for (int i = 0; i < n.fl.size(); i++)     		formals.add(false);          	Frame frame = currenFrame;    	currenFrame = frame.newFrame(Symbol.symbol(currenClass.getId() + "_" + n.i.s), formals);    	Stm s = null;          	if (n.sl.size() > 0)    		s = n.sl.elementAt(n.sl.size()-1).accept(this);          	for (int i = n.sl.size()-2; i >= 0; i--) {    		Statement st = n.sl.elementAt(i);    		s = new SEQ(st.accept(this), s);    	}          	AbstractExp returnExp = n.e.accept(this);          	Stm bodyStm;          	if (s == null) {    		bodyStm = new MOVE(new TEMP(currenFrame.RV()), returnExp);    	} else {    		AbstractExp eseq = new ESEQ(s, returnExp);    		bodyStm = new MOVE(new TEMP(currenFrame.RV()), eseq);    	}          	List<Stm> body = new ArrayList<>();          	body.add(bodyStm);          	currenFrame.procEntryExit1(body);          	ProcFrag frag = new ProcFrag(currenFrame, bodyStm);          	fragsResult.add(frag);          	currenFrame = frame;          	currenMethod = null;          	return null;	}	@Override	public Stm visit(Formal n) {		// TODO Auto-generated method stub		return null;	}	@Override	public Stm visit(IntArrayType n) {		// TODO Auto-generated method stub		return null;	}	@Override	public Stm visit(BooleanType n) {		// TODO Auto-generated method stub		return null;	}	@Override	public Stm visit(IntegerType n) {		// TODO Auto-generated method stub		return null;	}	@Override	public AbstractExp visit(IdentifierType n) {		// TODO Auto-generated method stub		return null;	}	@Override	public Stm visit(Block n) {    	Stm s = null; 	   	   	if (n.sl.size() > 0)	   		s = n.sl.elementAt(n.sl.size()-1).accept(this);				for (int i = n.sl.size()-2; i >= 0; i--) {			Statement st = n.sl.elementAt(i);			s = new SEQ(st.accept(this), s);		}		return s;	}	@Override	public Stm visit(If n) {	       Label t = new Label();	       Label f = new Label();	       Label join = new Label();	       	       AbstractExp condExp = n.e.accept(this);	       Stm thenStm = n.s1.accept(this);	       Stm elseStm = n.s2.accept(this);	       	       return new SEQ(new SEQ(new SEQ(new SEQ(new CJUMP(CJUMP.EQ, condExp, new CONST(1), t, f), 				  new SEQ(new LABEL(t), thenStm)), new JUMP(join)), new SEQ(new LABEL(f), elseStm)), new LABEL(join));	}	@Override	public Stm visit(While n) {		Label test = new Label();		Label body = new Label();		Label done = new Label();		AbstractExp condExp = n.e.accept(this);		Stm bodyStm = n.s.accept(this);				return new SEQ(new SEQ(new SEQ(new LABEL(test), new CJUMP(CJUMP.EQ, condExp, new CONST(1), body, done)),			       new SEQ(new LABEL(body), new SEQ(bodyStm, new JUMP(test)))), new LABEL(done));	}	@Override	public Stm visit(Print n) {		return new EXP(new CALL(new NAME(new Label("_printint")), new ExpList(n.e.accept(this), null)));	}	@Override	public Stm visit(Assign n) {    	AbstractExp left  = n.i.accept(this);    	AbstractExp right = n.e.accept(this);           	if (left instanceof TEMP)    		return new MOVE(left,  right);           	return new MOVE(new MEM(new BINOP(BINOP.PLUS, new TEMP(new Temp(0)), left)), right);	}	@Override	public Stm visit(ArrayAssign n) {    	AbstractExp arrayExp = n.i.accept(this);    	AbstractExp indexExp = n.e1.accept(this);    	AbstractExp valueExp = n.e2.accept(this);          	Label t = new Label();    	Label f = new Label();    	Temp indexTemp = new Temp();    	Temp sizeTemp = new Temp();    	indexExp = new ESEQ(new SEQ(new SEQ(new SEQ(new SEQ(new SEQ(new MOVE(new TEMP(indexTemp),    			new BINOP(BINOP.MUL, indexExp, new CONST(4))), new MOVE(new TEMP(sizeTemp), new MEM(arrayExp))),    			new CJUMP(CJUMP.GE, new TEMP(indexTemp), new TEMP(sizeTemp), t, f)), new LABEL(t)), new MOVE(    				new TEMP(new Temp()), new CALL(new NAME(new Label("_error")), null))), new LABEL(f)), new TEMP(indexTemp));    	    	if (!(arrayExp instanceof TEMP)) {    		Temp offsetTemp = new Temp();    		Temp returnTemp = new Temp();		      		arrayExp = new ESEQ(new SEQ(new MOVE(new TEMP(offsetTemp), new BINOP(BINOP.MUL, arrayExp, new CONST(4))), new MOVE(new TEMP(returnTemp),     								new MEM(new BINOP(BINOP.PLUS, new TEMP(new Temp(0)), new TEMP(offsetTemp))))), new TEMP(returnTemp));    	}        	return new MOVE(new MEM(new BINOP(BINOP.PLUS, arrayExp, new BINOP(BINOP.PLUS, indexExp, new CONST(4)))), valueExp);	}	@Override	public AbstractExp visit(And n) {		AbstractExp left  = n.e1.accept(this);		AbstractExp right = n.e2.accept(this);	   		Label leftTrue = new Label();		Label rightTrue = new Label();		Label join = new Label();		Temp result = new Temp();				return new ESEQ(new SEQ(new SEQ(new SEQ(new SEQ (new SEQ (new MOVE(new TEMP(result), new CONST(0)), new CJUMP(CJUMP.EQ, left, new CONST(1), leftTrue, join)),						new SEQ(new LABEL(leftTrue), new CJUMP(CJUMP.EQ, right, new CONST(1), rightTrue, join))), 						new SEQ(new LABEL(rightTrue),  new MOVE(new TEMP(result), new CONST(1)))), new JUMP(join)), new LABEL(join)), new TEMP(result));	}	@Override	public AbstractExp visit(LessThan n) {		AbstractExp left  = n.e1.accept(this);		AbstractExp right = n.e2.accept(this);				Label t = new Label();		Label f = new Label();		Temp result = new Temp();				return new ESEQ(new SEQ(new SEQ(new SEQ(new MOVE(new TEMP(result), new CONST(0)), 				new CJUMP(CJUMP.LT, left, right, t, f)), new SEQ(new LABEL(t), new MOVE(new TEMP(result), new CONST(1)))), 				new LABEL(f)), new TEMP(result));	}	@Override	public AbstractExp visit(Plus n) {		return new BINOP(BINOP.PLUS, n.e1.accept(this), n.e2.accept(this));	}	@Override	public AbstractExp visit(Minus n) {		return new BINOP(BINOP.MINUS, n.e1.accept(this), n.e2.accept(this));	}	@Override	public AbstractExp visit(Times n) {		return new BINOP(BINOP.MUL, n.e1.accept(this), n.e2.accept(this));	}	@Override	public AbstractExp visit(ArrayLookup n) {    	AbstractExp indexExp = n.e1.accept(this);    	AbstractExp arrayExp = n.e2.accept(this);          	Label t = new Label();    	Label f = new Label();    	Temp indexTemp = new Temp();    	Temp sizeTemp = new Temp();    	Temp result = new Temp();          	Stm calcIndex = new SEQ(new SEQ(new SEQ(new SEQ(new SEQ(new MOVE(new TEMP(indexTemp), new BINOP(BINOP.MUL, arrayExp, new CONST(4))),	    		  new MOVE(new TEMP(sizeTemp),new MEM(indexExp))), new CJUMP(CJUMP.GE, new TEMP(indexTemp), new TEMP(sizeTemp), t, f)),    		  		new LABEL(t)), new MOVE(new TEMP(new Temp()), new CALL(new NAME(new Label("_error")), null))), new LABEL(f));          	return new ESEQ(new SEQ(calcIndex, new MOVE(new TEMP(result), new MEM(new BINOP(BINOP.PLUS, indexExp,     				new BINOP(BINOP.PLUS,new BINOP(BINOP.MUL, arrayExp, new CONST(4)), new CONST(4)))))), new TEMP(result));	}	@Override	public AbstractExp visit(ArrayLength n) {		return new MEM(new BINOP(BINOP.PLUS, n.e.accept(this), new CONST(4)));	}	@Override	public AbstractExp visit(Call n) {    	AbstractExp methodExp = n.e.accept(this);    	ClassTable objectClass = null;    	int methodOffset = -1;	       	if (identifierClass == null) {    		methodOffset = instanceClass.getMethodOffset(n.i.s) * 4;    		if (instanceClass.getMethod(n.i.s).getReturnType() instanceof IdentifierType) {    			IdentifierType it = (IdentifierType) instanceClass.getMethod(n.i.s).getReturnType();    			objectClass = programTable.getClass(it.s);    		}    		    	} else {    		Type t = currenMethod.getFormalType(identifierClass);    		    		if (t == null)    			t = currenMethod.getLocalType(identifierClass);    		    		if (t == null)    			t = currenClass.getFieldType(identifierClass);		       		if (t == null)    			t = new IdentifierType(identifierClass);		       		ClassTable newClassTable = null;		       		if (t instanceof IdentifierType) {    			IdentifierType it = (IdentifierType) t;    			    			newClassTable = programTable.getClass(it.s);    			methodOffset = newClassTable.getMethodOffset(n.i.s) * 4;			       			if (newClassTable.getMethod(n.i.s).getReturnType() instanceof IdentifierType) {    				IdentifierType it2 = (IdentifierType) newClassTable.getMethod(n.i.s).getReturnType();    				objectClass = programTable.getClass(it2.s);    			}    		}		       	}    	if (objectClass != null)     		instanceClass = objectClass;	       	identifierClass = null;          	ExpList argsList = null; 	       	for (int i = n.el.size()-1; i >= 0; i--)    		argsList = new ExpList(n.el.elementAt(i).accept(this), argsList);    	    	Temp thisTemp = new Temp();    	    	argsList = new ExpList(new TEMP(thisTemp), argsList);    	    	Temp pointerTemp = new Temp();    	Temp methodTemp = new Temp();    	return new CALL(new ESEQ(new SEQ(new SEQ(new MOVE(new TEMP(thisTemp), methodExp), new MOVE(new TEMP(pointerTemp),    			new MEM(new TEMP(thisTemp)))), new MOVE(new TEMP(methodTemp), new MEM(new BINOP(BINOP.PLUS, new TEMP(pointerTemp),    					new CONST(methodOffset))))), new TEMP(methodTemp)), argsList);	}	@Override	public AbstractExp visit(IntegerLiteral n) {		return new CONST(n.i);	}	@Override	public AbstractExp visit(True n) {		return new CONST(1);	}	@Override	public AbstractExp visit(False n) {		return new CONST(0);	}	@Override	public AbstractExp visit(IdentifierExp n) {    	identifierClass = n.s;    	    	Temp t = currenMethod.getFormal(identifierClass);           	if (t == null)    		t = currenMethod.getLocal(identifierClass);           	if (t == null)    		return new MEM(new BINOP(BINOP.PLUS, new TEMP(new Temp(0)), new CONST(currenClass.getField(identifierClass))));    	    	return new TEMP(t);	}	@Override	public AbstractExp visit(This n) {		   identifierClass = currenClass.getId();		   		   return new TEMP(new Temp(0));	}	@Override	public AbstractExp visit(NewArray n) {    	AbstractExp arrayExp = n.e.accept(this);    	    	identifierClass = null;    	    	Label t = new Label();    	Label f = new Label();    	Label join = new Label();    	    	Temp pointerTemp = new Temp();    	Temp auxTemp = new Temp();    	    	AbstractExp sizeExp = new BINOP(BINOP.MUL, new BINOP(BINOP.PLUS, arrayExp, new CONST(1)), new CONST(4));    	    	return new ESEQ(new SEQ(new MOVE(new TEMP(pointerTemp), new CALL(new NAME(new Label("_halloc")),     			new ExpList(sizeExp, null))), new SEQ(new SEQ(new SEQ(new SEQ(new SEQ(new SEQ(new MOVE(new TEMP(auxTemp),     					new CONST(4)), new SEQ(new LABEL(join), new CJUMP(CJUMP.LT, new TEMP(auxTemp), sizeExp, f, t))),     					new LABEL(t)), new MOVE(new MEM(new BINOP(BINOP.PLUS, new TEMP(pointerTemp), new TEMP(auxTemp))),    					new CONST(0))), new MOVE(new TEMP(auxTemp), new BINOP(BINOP.PLUS, new TEMP(auxTemp), new CONST(4)))),    					new JUMP(join)), new SEQ(new LABEL(f), new MOVE(new MEM(new TEMP(pointerTemp)),     					new BINOP(BINOP.MUL, arrayExp, new CONST(4)))))), new TEMP(pointerTemp));	}	@Override	public AbstractExp visit(NewObject n) {    	AbstractExp result = new TEMP(new Temp());    	    	Stm seq = new MOVE(result, new CALL(new NAME(new Label("_halloc")), new ExpList(    			new CONST(currenFrame.wordSize() * (programTable.getClass(n.i.s).getFieldsSize() + 1)), null)));		          	for(int i = 0; i < programTable.getClass(n.i.s).getFieldsSize(); i++)    		seq = new SEQ(seq, new MOVE(new MEM(new BINOP(BINOP.PLUS, result, new CONST(i * currenFrame.wordSize()))),     					new CONST(0)));    	instanceClass = programTable.getClass(n.i.s);        	return new ESEQ(seq, result);	}	@Override	public AbstractExp visit(Not n) {		return new BINOP(BINOP.MINUS, new CONST(1), n.e.accept(this));	}	@Override	public AbstractExp visit(Identifier n) {		identifierClass = n.s;	      		Temp t = currenMethod.getFormal(identifierClass);       		if (t == null)			t = currenMethod.getLocal(identifierClass);       		if (t == null)			return new MEM(new BINOP(BINOP.PLUS, new TEMP(new Temp(0)), new CONST(currenClass.getField(identifierClass))));				return new TEMP(t);	}}