options {
  JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(MiniJavaParser)
  package core.lexical_analysis;
  import core.abstract_syntax.syntaxtree.*;
  public class MiniJavaParser {}
PARSER_END(MiniJavaParser)

SKIP: { //White space
		" "
	|	"\t"
	|	"\n"
	|	"\r"
	|	"\f"
}

SPECIAL_TOKEN : { //Comments
  		<SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
	| 	<MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN: { //Reserved words
	//MARKERS
		< LPAREN: "(" >
	|	< RPAREN: ")" >
	|	< LSQPAREN: "[" >
	|	< RSQPAREN: "]" >
	|	< LBRACE: "{" >
	|	< RBRACE: "}" >
	|	< SEMICOLON: ";" >
	|	< COMMA : "," >
	|	< DOT: "." >
	
	//ARITHMETIC OPERATORS
	|	< PLUS: "+" >
	|	< MINUS: "-" >
	|	< TIMES: "*" >
	|	< DIVIDED: "/" >
	|	< ASSIGN: "=" >

	//CONDITIONNAL
	|	< ELSE: "else" >
	|	< IF: "if" >
	|	< FALSE: "false" >
	|	< TRUE: "true" >

	//LOGIC OPERATORS 
	|	< AND: "&&" >
	|	< NOT: "!" >
	|	< LT: "<" >
	|	< GT: ">" >
	|	< EQUALS: "==" >

	//VARIABLES TYPES
	|	< BOOLEAN: "boolean" >
	|	< INTEGER: "int" >
	
	//OO TOKENS
	|	< CLASS: "class" >
	|	< EXTENDS: "extends" >
	|	< MAIN: "main" >
	|	< NEW: "new" >
	|	< PUBLIC: "public" >
	|	< THIS: "this" >
	|	< STATIC: "static">	
	
	//MISCELANEOUS
	|	< PRINT: "System.out.println" >
	|	< RETURN: "return" >
	|	< WHILE: "while" >
	|	< LENGTH: "length" >
	|	< STRING: "String" >
	|	< VOID: "void" >
	
	//Literals
	|	<  INTEGER_LITERAL: ( ["1"-"9"] (<DIGIT >)* | "0" ) >

	//Identifiers
	|	< IDENTIFIER: < LETTER > (< LETTER >| < DIGIT >)* >

	|	< #LETTER:
			[
			"$",
			"A"-"Z",
			"_",
			"a"-"z"
			]
	 	>	

	|	< #DIGIT:
      		[
	       "0"-"9" 
      		]
  	 	>
}

Program Program():
{
	MainClass mc;
	ArrayList<ClassDecl> cdl;
}
{
  mc = MainClass()
  cdl = ClassDeclList()
  < EOF >
  //TODO
  { return new Program(mc,cdl); }
}

ArrayList<ClassDecl> ClassDeclList() :
{
  	ArrayList<ClassDecl> cdl = new ArrayList<ClassDecl>();
	ClassDecl c;
}
{
	(c = ClassDeclaration() { cdl.add(c); })*
	{ return cdl.size() > 0 ? cdl : null; }
}

MainClass MainClass():
{
	Identifier id1,id2;
	ArrayList<Statement> stms
	
}
{
  < CLASS > id1 = < IDENTIFIER > < LBRACE >
  	< PUBLIC > < STATIC > < VOID > < MAIN > < LPAREN > < STRING > < LSQPAREN > < RSQPAREN > id2 = < IDENTIFIER > < RPAREN > < LBRACE >
  		stms = Statement()
  	< RBRACE >
  < RBRACE >

  {return new MainClass(id1,id2,stms);}
}


ClassDecl ClassDeclaration():
{
	Identifier id,ex;
	ClassDecl cl;
	VarDeclList vl = new VarDeclList();
	MethodDeclList ml = new MethodDeclList();
	VarDecl v;
	MethodDecl m;
}
{
  < CLASS > id = < IDENTIFIER > ( < EXTENDS > ex = < IDENTIFIER > )? < LBRACE > ( v = VarDeclaration() { vl.addElement(v); })* ( m = MethodDeclaration() { ml.addElement(m); })* < RBRACE >
	{if(ex!=null) return new ClassDeclExtends(id,ex,vl,ml);
	 return new ClassDeclSimple(id,vl,ml) }
		
	  
}

void VarDeclaration():
{
	Type t;
	Identifier id;
}
{
  t = Type() id = < IDENTIFIER > < SEMICOLON >
  {return new VarDecl(t,id);}
}

void MethodDeclaration():
{
  Type at;
  Identifier ai;
  FormalList afl;
  VarDeclList avl;
  VarDecl v;
  StatementList asl,sl;
  Exp ae;
}
{
  < PUBLIC > at = Type() ai = < IDENTIFIER > < LPAREN > afl = FormalList() < RPAREN > < LBRACE > ( LOOKAHEAD(2) v = VarDeclaration() { avl.addElement(v);})* ( sl = Statement() {asl.joinAtEnd(sl);})* < RETURN > ae = Expression() < SEMICOLON > < RBRACE >
  {return new MethodDeclaration(Type at, Identifier ai, FormalList afl, VarDeclList avl, 
                    StatementList asl, Exp ae)}
}

void FormalList():
{}
{
  Type() < IDENTIFIER > (FormalRest())*
}

void FormalRest():
{}
{
  < COMMA > Type() < IDENTIFIER >
}

void Type():
{}
{ < INTEGER > ( < LSQPAREN > < RSQPAREN > )?
| < BOOLEAN >
| < IDENTIFIER >
}

void Statement():
{
  	StatementList s,ifStm,elseStm,stms = new StatementList();
	Exp ae, aeI;
	Identifier id;
}
{ < LBRACE > ( s = Statement() { stms.joinAtEnd(s); } )* < RBRACE >
| < IF > < LPAREN > ae = Expression() < RPAREN > ifStm = Statement() < ELSE > elseStm = Statement() { stms.add(new If(ae,ifStm,elseStm)); }
| < WHILE > < LPAREN > ae = Expression() < RPAREN > s = Statement() { stms.add(new While(ae,s));}
| < PRINT > < LPAREN > ae = Expression() < RPAREN > < SEMICOLON > { stms.add(new Print(ae)); }
| id = < IDENTIFIER > ( < ASSIGN > ae = Expression() < SEMICOLON > { stms.add(new Assign(id, ae)); }
				 | < LSQPAREN > aeI = Expression() < RSQPAREN > < ASSIGN >  ae = Expression() < SEMICOLON > { stms.add(new ArrayAssign(id,aeI,ae)); }
				 )
	{return stms; }
}

void Expression():
{}
{ ( <INTEGER_LITERAL>
  | < TRUE >
  | < FALSE >
  | < IDENTIFIER >
  | < THIS >
  | < NEW > ( < INTEGER > < LSQPAREN > Expression() < RSQPAREN > | < IDENTIFIER > < LPAREN > < RPAREN > )
  | < NOT > Expression()
  | < LPAREN > Expression() < RPAREN >
  ) Expression_()
}

void Expression_():
{}
{ ( LOOKAHEAD(2) ( ( < AND > | < LT > | < PLUS > | < MINUS > | < TIMES > ) Expression()			     | < LSQPAREN > Expression() < RSQPAREN >
			     | < DOT > ( < LENGTH > | < IDENTIFIER > < LPAREN > ExpList() < RPAREN > )
			     ) Expression_()
  )?
}

void ExpList():
{}
{
  Expression() ( ExpRest() )*
}

void ExpRest():
{}
{
  < COMMA > Expression()
}

void MiniJavaToken():
{}
{
  < CLASS > | < LBRACE > | < PUBLIC > | < STATIC > | < VOID > |
  < MAIN > | < LPAREN > | < STRING >  | < LSQPAREN > | < RSQPAREN > | < RPAREN > | < RBRACE > | < EXTENDS > | < SEMICOLON >
  | < RETURN > | < COMMA > | < INTEGER > | < BOOLEAN > | < ASSIGN > | < IF > | < ELSE > | < WHILE >
  | < PRINT > | < AND > | < LT > | < PLUS > | < MINUS > | < TIMES > | < DOT > |
  < LENGTH > |  < TRUE > | < FALSE > | < THIS > | < NEW > |
  < NOT >
}


