options {
  JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(MiniJavaParser)
  package core.lexical_analysis;
  import core.abstract_syntax.syntaxtree.*;
  public class MiniJavaParser {}
PARSER_END(MiniJavaParser)

SKIP: { //White space
		" "
	|	"\t"
	|	"\n"
	|	"\r"
	|	"\f"
}

SPECIAL_TOKEN : { //Comments
  		<SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
	| 	<MULTI_LINE_COMMENT: "/*" (~["*"])* "*" ("*" | (~["*","/"] (~["*"])* "*"))* "/">
}

TOKEN: { //Reserved words
	//MARKERS
		< LPAREN: "(" >
	|	< RPAREN: ")" >
	|	< LSQPAREN: "[" >
	|	< RSQPAREN: "]" >
	|	< LBRACE: "{" >
	|	< RBRACE: "}" >
	|	< SEMICOLON: ";" >
	|	< COMMA : "," >
	|	< DOT: "." >
	
	//ARITHMETIC OPERATORS
	|	< PLUS: "+" >
	|	< MINUS: "-" >
	|	< TIMES: "*" >
	|	< DIVIDED: "/" >
	|	< ASSIGN: "=" >

	//CONDITIONNAL
	|	< ELSE: "else" >
	|	< IF: "if" >
	|	< FALSE: "false" >
	|	< TRUE: "true" >

	//LOGIC OPERATORS 
	|	< AND: "&&" >
	|	< NOT: "!" >
	|	< LT: "<" >
	|	< GT: ">" >
	|	< EQUALS: "==" >

	//VARIABLES TYPES
	|	< BOOLEAN: "boolean" >
	|	< INTEGER: "int" >
	
	//OO TOKENS
	|	< CLASS: "class" >
	|	< EXTENDS: "extends" >
	|	< MAIN: "main" >
	|	< NEW: "new" >
	|	< PUBLIC: "public" >
	|	< THIS: "this" >
	|	< STATIC: "static">	
	
	//MISCELANEOUS
	|	< PRINT: "System.out.println" >
	|	< RETURN: "return" >
	|	< WHILE: "while" >
	|	< LENGTH: "length" >
	|	< STRING: "String" >
	|	< VOID: "void" >
	
	//Literals
	|	<  INTEGER_LITERAL: ( ["1"-"9"] (<DIGIT >)* | "0" ) >

	//Identifiers
	|	< IDENTIFIER: < LETTER > (< LETTER >| < DIGIT >)* >

	|	< #LETTER:
			[
			"$",
			"A"-"Z",
			"_",
			"a"-"z"
			]
	 	>	

	|	< #DIGIT:
      		[
	       "0"-"9" 
      		]
  	 	>
}

Program Program():
{
	MainClass mc;
	ClassDeclList cdl;
}
{
	mc = MainClass()
  	cdl = ClassDeclList()
  	< EOF >
  	//TODO
  { return new Program(mc,cdl); }
}

ClassDeclList ClassDeclList() :
{
  	ClassDeclList cdl = new ClassDeclList();
	ClassDecl c;
}
{
	(c = ClassDeclaration() { cdl.addElement(c); })*
	{ return cdl.size() > 0 ? cdl : null; }
}

MainClass MainClass():
{
	Identifier id1,id2;
	StatementList stml = new StatementList();
	Statement stm;
}
{
	< CLASS > id1 = < IDENTIFIER > < LBRACE >
	< PUBLIC > < STATIC > < VOID > < MAIN > < LPAREN > < STRING > < LSQPAREN > < RSQPAREN > id2 = < IDENTIFIER > < RPAREN > < LBRACE >
	stm = Statement() {stml.joinAtEnd(stm);}
	< RBRACE >
	< RBRACE >

	{return new MainClass(id1,id2,stms);}
}


ClassDecl ClassDeclaration():
{
	Identifier id,ex;
	ClassDecl cl;
	VarDeclList vl = new VarDeclList();
	MethodDeclList ml = new MethodDeclList();
	VarDecl v;
	MethodDecl m;
}
{
	< CLASS > id = < IDENTIFIER > ( < EXTENDS > ex = < IDENTIFIER > )? < LBRACE > ( v = VarDeclaration() { vl.addElement(v); })* ( m = MethodDeclaration() { ml.addElement(m); })* < RBRACE >
	{
		if(ex!=null) return new ClassDeclExtends(id,ex,vl,ml);
		return new ClassDeclSimple(id,vl,ml);
	}
		
	  
}

void VarDeclaration():
{
	Type t;
	Identifier id;
}
{
	t = Type() id = < IDENTIFIER > < SEMICOLON >
	{return new VarDecl(t,id);}
}

MethodDeclaration MethodDeclaration():
{
	Type at;
	Identifier ai;
	FormalList afl;
	VarDeclList avl;
	VarDecl v;
	StatementList asl,sl;
	Exp ae;
}
{
	< PUBLIC > at = Type() ai = < IDENTIFIER > < LPAREN > afl = FormalList() < RPAREN > < LBRACE > ( LOOKAHEAD(2) v = VarDeclaration() { avl.addElement(v);})* ( sl = Statement() {asl.joinAtEnd(sl);})* < RETURN > ae = Expression() < SEMICOLON > < RBRACE >
	{return new MethodDeclaration(at, ai, afl, avl, asl, ae);}
}

FormalList FormalList():
{
	FormalList fl = new FormalList();
	FormalRest f;
	Type t;
	Identifier id;
}
{
	t = Type() id = < IDENTIFIER > (f = FormalRest() {fl.addElement(f);})*
	{return fl;}
}

Formal FormalRest():
{
	Type t;
	Identifier id;
}
{
	< COMMA > t = Type() id = < IDENTIFIER >

	{return new Formal(t,id);}
}

Type Type():
{
	IdentifierType it;
}
{ < INTEGER > {t = new IntegerType();} ( < LSQPAREN > < RSQPAREN > {t = new IntArrayType();})?
| < BOOLEAN > {t = new BooleanType();}
| < IDENTIFIER > {t = new IntegerType();}
}

StatementList Statement():
{
	StatementList s,ifStm,elseStm,stms = new StatementList();
	Exp ae, aeI;
	Identifier id;
}
{ < LBRACE > ( s = Statement() { stms.joinAtEnd(s); } )* < RBRACE >
| < IF > < LPAREN > ae = Expression() < RPAREN > ifStm = Statement() < ELSE > elseStm = Statement() { stms.add(new If(ae,ifStm,elseStm)); }
| < WHILE > < LPAREN > ae = Expression() < RPAREN > s = Statement() { stms.add(new While(ae,s));}
| < PRINT > < LPAREN > ae = Expression() < RPAREN > < SEMICOLON > { stms.add(new Print(ae)); }
| id = < IDENTIFIER > ( < ASSIGN > ae = Expression() < SEMICOLON > { stms.add(new Assign(id, ae)); }
				 | < LSQPAREN > aeI = Expression() < RSQPAREN > < ASSIGN >  ae = Expression() < SEMICOLON > { stms.add(new ArrayAssign(id,aeI,ae)); }
				 )
	{return stms; }
}

Exp Expression():
{
	Exp exp;
	IntegerLiteral i;
	Identifier id;
}
{
	( i = <INTEGER_LITERAL> {exp = new IntegerLiteral(i);}
	| < TRUE > {exp = new True();}
	| < FALSE > {exp = new False();}
	| id = < IDENTIFIER > {exp = new IdentifierExp(id.toString());}
	| < THIS > { exp = new This();}
	| < NEW > ( < INTEGER > < LSQPAREN > exp = Expression() < RSQPAREN > {exp = new NewArray(exp);} | id = < IDENTIFIER > < LPAREN > < RPAREN > {exp = new NewObject(id);} )
	| < NOT > exp = Expression() { exp = new Not(exp);}
	| < LPAREN > exp = Expression() < RPAREN >
	) Expression_()

	{return exp;}
}

Exp Expression_():
{}
{ ( LOOKAHEAD(2) ( ( < AND > | < LT > | < PLUS > | < MINUS > | < TIMES > ) Expression()			     | < LSQPAREN > Expression() < RSQPAREN >
			     | < DOT > ( < LENGTH > | < IDENTIFIER > < LPAREN > ExpList() < RPAREN > )
			     ) Expression_()
  )?
}

ExpList ExpList():
{
	ExpList expl = new ExpList();
	Exp exp;
}
{
	exp = Expression() {expl.addElement(exp);} ( exp = ExpRest() {expl.addElement(exp);} )*
	{return expl;}
}

Exp ExpRest():
{
	Exp exp;
}
{
	< COMMA > exp = Expression()
	{return exp;}
}

void MiniJavaToken():
{}
{
  < CLASS > | < LBRACE > | < PUBLIC > | < STATIC > | < VOID > |
  < MAIN > | < LPAREN > | < STRING >  | < LSQPAREN > | < RSQPAREN > | < RPAREN > | < RBRACE > | < EXTENDS > | < SEMICOLON >
  | < RETURN > | < COMMA > | < INTEGER > | < BOOLEAN > | < ASSIGN > | < IF > | < ELSE > | < WHILE >
  | < PRINT > | < AND > | < LT > | < PLUS > | < MINUS > | < TIMES > | < DOT > |
  < LENGTH > |  < TRUE > | < FALSE > | < THIS > | < NEW > |
  < NOT >
}


